{"meta":{"title":"Dreamscape","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Hexo注入","slug":"Hexo注入","date":"2022-03-01T16:00:00.000Z","updated":"2022-03-02T00:27:51.920Z","comments":true,"path":"2022/03/02/Hexo注入/","link":"","permalink":"http://yoursite.com/2022/03/02/Hexo%E6%B3%A8%E5%85%A5/","excerpt":"","text":"配置新版本好像集成了插件, 运行npm install hexo-abbrlink --save提示已安装 12345#修改配置文件_config.ymlpermalink: posts/:abbrlink/abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hexo设置永久链接","slug":"Hexo设置永久链接","date":"2022-03-01T16:00:00.000Z","updated":"2022-03-01T23:38:26.409Z","comments":true,"path":"2022/03/02/Hexo设置永久链接/","link":"","permalink":"http://yoursite.com/2022/03/02/Hexo%E8%AE%BE%E7%BD%AE%E6%B0%B8%E4%B9%85%E9%93%BE%E6%8E%A5/","excerpt":"","text":"配置新版本好像集成了插件, 运行npm install hexo-abbrlink --save提示已安装 12345#修改配置文件_config.ymlpermalink: posts/:abbrlink/abbrlink: alg: crc32 #算法： crc16(default) and crc32 rep: hex #进制： dec(default) and hex","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"std::istream::getline是否线程安全","slug":"getline线程安全","date":"2022-01-29T16:00:00.000Z","updated":"2022-02-02T03:40:06.821Z","comments":true,"path":"2022/01/30/getline线程安全/","link":"","permalink":"http://yoursite.com/2022/01/30/getline%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/","excerpt":"","text":"试验将若干文件的路径写进入一个文本文档中,然后读取文档中保存的文件路径,然后计算MD5值并写入MySQL数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class FileMD5Thread &#123;private: char* listFile; char* outMD5File; unsigned short int threadCount = 24;//线程数 static std::mutex logLock;//日志锁 std::mutex* plck;//默认所有对象使用相同的锁 ......&#125;int FileMD5Thread::fileMd5Sum(sql::Statement* state, ThreadsAction action)&#123; constexpr int FILE_NAME_PATH_SIZE = 512; //char* buff = new char[FILE_NAME_PATH_SIZE*2]; char buff[FILE_NAME_PATH_SIZE * 2] = &#123; 0 &#125;; char buffMD5[128] = &#123; 0 &#125;; char fileName[FILE_NAME_PATH_SIZE] = &#123; 0 &#125;; char filePath[FILE_NAME_PATH_SIZE] = &#123; 0 &#125;; while (inFile.getline(buff, FILE_NAME_PATH_SIZE)) &#123; try &#123;// 捕捉getFileMD5抛出的错误 strcpy(buffMD5, getFileMD5(buff).c_str()); &#125; catch (...) &#123; this-&gt;endResetZero(buffMD5, 128); std::lock_guard&lt;std::mutex&gt; lockguard(logLock); errors++; outLog &lt;&lt; &quot;无法定位文件: &quot; &lt;&lt; buff &lt;&lt; endl; cout &lt;&lt; &quot;无法定位文件: &quot; &lt;&lt; buff &lt;&lt; endl; &#125; cutStr(buff, filePath, fileName, &#x27;\\\\&#x27;); switch (action) &#123; case FileMD5Thread::ThreadsAction::TO_MYSQL: &#123; /*写入数据库*/ sprintf(buff, &quot;insert into mods_test(md5,filename,path) value(\\&quot;%s\\&quot;,\\&quot;%s\\&quot;,\\&quot;%s\\&quot;)&quot;, buffMD5, fileName, filePath); gbkToUTF8(buff, FILE_NAME_PATH_SIZE); try &#123; std::lock_guard&lt;std::mutex&gt; lockguard(*plck); state-&gt;executeUpdate(buff); &#125; catch (...) &#123; std::lock_guard&lt;std::mutex&gt; lockguard(logLock); errors++; outLog &lt;&lt; buff &lt;&lt; endl; &#125; &#125; break; case FileMD5Thread::ThreadsAction::TO_FILE: &#123; /*写入文件*/ std::lock_guard&lt;std::mutex&gt; lockguard(*plck); //outFile &lt;&lt; buff &lt;&lt; endl &lt;&lt; &quot;[MD5]&quot; &lt;&lt; buffMD5 &lt;&lt; endl;//写入文件 outLog &lt;&lt; fileName &lt;&lt; &quot; &quot; &lt;&lt; filePath &lt;&lt; endl; outLog &lt;&lt; buff &lt;&lt; endl &lt;&lt; endl; &#125; break; default: &#123; cout &lt;&lt; &quot;别乱搞!&quot; &lt;&lt; endl; return 404; &#125; break; &#125;//switch end this-&gt;endResetZero(buff, FILE_NAME_PATH_SIZE); this-&gt;endResetZero(fileName, FILE_NAME_PATH_SIZE); this-&gt;endResetZero(filePath, FILE_NAME_PATH_SIZE); &#125; //delete[] buff; return errors;&#125; 123456789101112131415161718192021222324252627282930313233/*==========以下是开启多线程的函数==========*/int FileMD5Thread::run(sql::Connection* conn)&#123; /*传入Connection对象时,写入MySQL数据库 */ clock_t start_time = clock();//计时开始 openIoFile(); std::mutex lckSQL;//SQL写入锁 this-&gt;plck = &amp;lckSQL; sql::Statement* state = conn-&gt;createStatement(); thread* pth = new thread[threadCount]; if (pth == NULL) &#123; return 404; &#125; int i; for (i = 0; i &lt; threadCount; i++) &#123; pth[i] = thread(&amp;FileMD5Thread::fileMd5Sum, this, state, ThreadsAction::TO_MYSQL); &#125; for (i = 0; i &lt; threadCount; i++) &#123; pth[i].join(); &#125; //计时结束 clock_t end_time = clock(); outLog &lt;&lt; &quot;elapsed time:&quot; &lt;&lt; (double)clock() / CLK_TCK &lt;&lt; &quot;s\\n&quot; &lt;&lt; &quot;error count: &quot; &lt;&lt; errors; //收尾 state-&gt;close(); delete state; delete[] pth; closeIoFile(); return errors;&#125; 在MySQL查询结果12mysql&gt; SELECT md5,COUNT(*) AS CONTMD5 FROM mods_test GROUP BY md5 HAVING CONTMD5%14!&#x3D;0;Empty set 我一共运行了14次程序. 此时对数据进行分组并计数,只要计数能被14整除,那说明getline在多线程操读取且没有上锁的情况下,没有重复读取一行或者漏读一行数据. 从试验结果来看,getline是线程安全的.","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"使用gitbash连接GitHub仓库遇到的一点小问题","slug":"使用gitbash连接GitHub仓库","date":"2022-01-28T16:00:00.000Z","updated":"2022-01-29T23:48:28.664Z","comments":true,"path":"2022/01/29/使用gitbash连接GitHub仓库/","link":"","permalink":"http://yoursite.com/2022/01/29/%E4%BD%BF%E7%94%A8gitbash%E8%BF%9E%E6%8E%A5GitHub%E4%BB%93%E5%BA%93/","excerpt":"","text":"太难了(:з」∠)1234git remote add origin URL提示:fatal: not a git repository (or any of the parent directories): .git输入:git init初始化","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"使用iptables转发DNS请求","slug":"使用iptables转发DNS请求","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-18T06:29:33.457Z","comments":true,"path":"2022/01/10/使用iptables转发DNS请求/","link":"","permalink":"http://yoursite.com/2022/01/10/%E4%BD%BF%E7%94%A8iptables%E8%BD%AC%E5%8F%91DNS%E8%AF%B7%E6%B1%82/","excerpt":"","text":"OpenWrt路由器上的SmartDNS提供DNS服务,侦听端口为6053,Windows不能指定DNS端口号所以试着用一台内网Ubuntu虚拟机转发DNS请求. 123456789101112131415#!/bin/bashDNS_server=&quot;192.168.1.1&quot;DNS_port=&quot;6053&quot;iptables -t nat -A PREROUTING -p udp --dport 53 -j DNAT --to-destination $&#123;DNS_server&#125;:$&#123;DNS_port&#125;iptables -t nat -A PREROUTING -p tcp --dport 53 -j DNAT --to-destination $&#123;DNS_server&#125;:$&#123;DNS_port&#125;iptables -t nat -A POSTROUTING -p udp -d $&#123;DNS_server&#125; --dport $&#123;DNS_port&#125; -j MASQUERADEiptables -t nat -A POSTROUTING -p tcp -d $&#123;DNS_server&#125; --dport $&#123;DNS_port&#125; -j MASQUERADEiptables -I FORWARD -d $&#123;DNS_server&#125; -p udp --dport $&#123;DNS_port&#125; -j ACCEPTiptables -I FORWARD -s $&#123;DNS_server&#125; -p udp --sport $&#123;DNS_port&#125; -j ACCEPTiptables -I FORWARD -d $&#123;DNS_server&#125; -p tcp --dport $&#123;DNS_port&#125; -j ACCEPTiptables -I FORWARD -s $&#123;DNS_server&#125; -p tcp --sport $&#123;DNS_port&#125; -j ACCEPT","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"最近折腾虚拟机常用的Linux命令","slug":"最近折腾虚拟机常用的Linux命令","date":"2022-01-06T16:00:00.000Z","updated":"2022-01-18T06:29:33.457Z","comments":true,"path":"2022/01/07/最近折腾虚拟机常用的Linux命令/","link":"","permalink":"http://yoursite.com/2022/01/07/%E6%9C%80%E8%BF%91%E6%8A%98%E8%85%BE%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B8%B8%E7%94%A8%E7%9A%84Linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Ubuntu123ssh-keygen -t rsa -b 4096 #生成4096长度的RSA密钥对,用于sshsudo systemctl set-default multi-user.target #关闭GUIsudo systemctl set-default graphical.target #启用GUI 将网卡名改成eth0123#在 /etc/default/grub 文件中编辑,修改完后执行命令 update-grubGRUB_CMDLINE_LINUX 引号中添加参数 net.ifnames=0 biosdevname=0#修改完成后重启 ESXi12vmkfstools --punchzero #回收VMDK虚拟磁盘空间vmkfstools -i oldfile newfile -d thin #转换esxi能使用的vmdk PVE1234#VMDK转qcow2qemu-img convert -f vmdk -O qcow2 Lubuntu.vmdk Lubuntu.qcow2#导入磁盘qm importdisk 103 vm-103-disk-2.qcow2 local","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Ubuntu通过RSA公钥登录SSH","slug":"Ubuntu通过RSA公钥登录SSH","date":"2021-12-22T16:00:00.000Z","updated":"2022-01-18T06:29:33.370Z","comments":true,"path":"2021/12/23/Ubuntu通过RSA公钥登录SSH/","link":"","permalink":"http://yoursite.com/2021/12/23/Ubuntu%E9%80%9A%E8%BF%87RSA%E5%85%AC%E9%92%A5%E7%99%BB%E5%BD%95SSH/","excerpt":"","text":"1.客户端创建密钥对123PS C:\\Windows\\system32&gt;ssh-keygen -t rsa -b 4096 #创建RSA密钥对,长度为4096#一路回车或者按需设置秘钥锁码#公钥文件可以在C:\\Users\\用户名\\.ssh 目录找到 2.在服务器上安装公钥12#安装ssh服务,Ubuntu默认只有ssh客户端sudo apt-get install openssh-server 导入公钥至服务端1234567#将客户端id_rsa.pub中的内容复制进服务端authorized_keys文件中,如果没有此文件需要手动创建sudo touch ~/.ssh/authorized_keys#authorized_keys需要600权限sudo chmod 600 authorized_keys#重启ssh服务service sshd restart","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"}]},{"title":"通过dig命令理解DNS迭代解析","slug":"通过dig命令理解DNS迭代解析","date":"2020-08-22T16:36:39.000Z","updated":"2022-01-18T06:29:33.457Z","comments":true,"path":"2020/08/23/通过dig命令理解DNS迭代解析/","link":"","permalink":"http://yoursite.com/2020/08/23/%E9%80%9A%E8%BF%87dig%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3DNS%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%9E%90/","excerpt":"","text":"最近给Github Pages弄域名和CDN加速,为了查看DNS的解析过程,稍微学习了DNS迭代解析. 迭代解析是以DNS客户端为中心进行查询,如图所示: DNS迭代解析流程下面以Linux系统下的dig +trace blog.dreamscape.ink为例: 获取本地DNS记录的全球根域名服务器地址 最先回复的根域名服务器将ink顶级域名服务器列表返回给客户端 根域名服务器199.9.14.201:53(b.root-servers.net)返回ink顶级域名服务器列表. .ink顶级域名服务器返回二级域名dreamscape.ink的NS服务器列表 .ink顶级域名服务器212.18.248.41:53(c.nic.ink)查询得到dreamscape.ink是由cloudflare管理的,返回cloudflare的NS地址. cloudflareDNS服务器返回最终的结果. cloudflareDNS服务器108.162.195.191:53(tate.ns.cloudflare.com)将查询到blog.dreamscape.ink的A记录信息返回给客户端. blog.dreamscape.ink是经过cloudflare的CDN加速域名,返回了3条A记录,这三条A记录就是最终查询结果.","categories":[],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"}]},{"title":"解析JSON","slug":"json解析","date":"2020-08-09T16:00:00.000Z","updated":"2022-01-18T06:29:33.457Z","comments":true,"path":"2020/08/10/json解析/","link":"","permalink":"http://yoursite.com/2020/08/10/json%E8%A7%A3%E6%9E%90/","excerpt":"","text":"JSON:JavaScript Object Notation ,JS对象简谱 , 是一种轻量级的数据交换格式. 本文讲解使用GSON解析JSON Gson的使用前提:导入gson的jar包 思路:把JSON字符串转成Java对象 主要的方法： Gson fromJson(String jsonString,Object) 用于把json字符串转换成java对象 String toJson(Object obj) 把obj对象变成json字符串 解析json字符串首先创建一个用于解析的字符串.这里用对象创建,创建后把结果写入文件.123456789101112131415161718192021222324252627282930313233public class TestJSON &#123; @Test public void testJSON() throws IOException &#123; Per p=new Per(&quot;Alice&quot;,23); //创建json对象 Gson gson = new Gson(); //获取对象p的json字符串 String json = gson.toJson(p); System.out.println(json); //写入文件 File file=new File(&quot;E:\\\\CSOURCE\\\\Kaikeba\\\\lib\\\\test\\\\test\\\\test1.json&quot;); PrintStream ps=new PrintStream(file); ps.println(json); ps.close(); &#125; //用于创建Json字符串的类 class Per&#123; String name=&quot;NULL&quot;; int age=-1; public Per(String name, int age) &#123; this.name = name; this.age = age; &#125; public Per() &#123; &#125; @Override public String toString() &#123; return &quot;Per&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; &#125; 输出的内容: 从json文件获取json字符串后进行解析1234567891011121314@Testpublic void testJSON() throws IOException &#123; File file=new File(&quot;E:\\\\CSOURCE\\\\Kaikeba\\\\lib\\\\test\\\\test\\\\test1.json&quot;); //由json文件创建对象 Per p2=new Per(); //打印默认值 System.out.println(&quot;默认值:&quot;+p2); //获取带缓存的字符输入流 BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(file))); //解析json字符串并将数据写入对象p2 String s=br.readLine(); p2=gson.fromJson(s,Per.class); System.out.println(&quot;由json文件读入的对象数值:&quot;+p2);&#125; 解析数组123456789101112@Testpublic void analysisJSON()&#123; //创建JSON对象 Gson gson=new Gson(); //转换 &#123;&quot;id&quot;:[100,104,105,233,256]&#125; HashMap data=gson.fromJson(&quot;&#123;\\&quot;id\\&quot;:[100,104,105,233,256]&#125;&quot;,HashMap.class); List id= (List) data.get(&quot;id&quot;); //遍历列表 for(Object o:id)&#123; System.out.println(o); &#125;&#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"线程与进程 并发与并行","slug":"线程与进程 并发与并行","date":"2020-08-09T16:00:00.000Z","updated":"2022-01-18T06:29:33.457Z","comments":true,"path":"2020/08/10/线程与进程 并发与并行/","link":"","permalink":"http://yoursite.com/2020/08/10/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/","excerpt":"","text":"1.线程与进程 进程(Process)是Windows系统中的一个基本概念,它包含着一个运行程序所需要的资源.一个正在运行的程序在操作系统中被视为一个进程,进程可以包括一个或多个线程. 线程(Thread):是进程中的基本执行单元,是操作系统分配CPU时间的基本单位,一个进程可以包含若干个线程,在进程入口执行的第一个线程被视为这个进程的主线程. 2.并发与并行并发是指一个时间段内,有若干程序都在同一个CPU上运行,但任意一个时刻只有一个程序在运行. 并行是指一个时间段内,有若干程序都在几个CPU上运行任意一个时刻点上,有多个程序在同时运行,并且多个程序之间互不干扰. 两者区别如图所示: 并行是多个程序在多个CPU(核心)上同时运行,任意一个时刻可以有很多个程序同时运行,互不干扰. 并发是多个程序在一个CPU上运行,CPU在多个程序之间快速切换,微观上不是同时运行,任意一个时刻只有一个程序在运行,但因为CPU切换速度非常快,所以给人感觉像多个程序同时运行一样,你还没反应过来,CPU已经切换了好几个程序了.","categories":[],"tags":[]},{"title":"Try-catch造成死循环(无限递归)的问题","slug":"Try-catch造成死循环(无限递归)的问题","date":"2020-08-07T16:00:00.000Z","updated":"2022-03-03T00:46:43.045Z","comments":true,"path":"2020/08/08/Try-catch造成死循环(无限递归)的问题/","link":"","permalink":"http://yoursite.com/2020/08/08/Try-catch%E9%80%A0%E6%88%90%E6%AD%BB%E5%BE%AA%E7%8E%AF(%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92)%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"_(:з」∠)_","text":"直接上代码:1234567891011121314151617181920import java.util.Scanner;public class TryCatch &#123; public static void main(String[] args) &#123; new Test1().test(); &#125; public static class Test1 &#123; Scanner input=new Scanner(System.in); public int test()&#123; System.out.println(&quot;请输入:&quot;); int temp=1; try&#123; temp=input.nextInt(); &#125;catch(Exception e)&#123; return test(); &#125; System.out.println(temp); return temp; &#125; &#125;&#125; 这段代码原本是想用于接收用户输入并判断输入是否合法,如果输入不合法则调用自己让用户重新输入一次数据.结果输入字符串时造成死循环 然后爆栈… 于是进入调试模式查找问题. 在调试模式中发现 input.nextInt()方法的异常在递归时并未清除而是保留下来,所以catch中的条件一直被触发,造成死循环. 解决方法:在方法中创建Scanner对象. 1234567891011121314public static class Test1 &#123; public int test()&#123; Scanner input=new Scanner(System.in); System.out.println(&quot;请输入:&quot;); int temp=1; try&#123; temp=input.nextInt(); &#125;catch(Exception e)&#123; return test(); &#125; System.out.println(temp); return temp; &#125;&#125;","categories":[],"tags":[]},{"title":"JAVA创建类类型数组遇到的问题","slug":"JAVA创建类类型数组遇到的问题","date":"2020-07-19T16:00:00.000Z","updated":"2022-01-18T06:29:33.368Z","comments":true,"path":"2020/07/20/JAVA创建类类型数组遇到的问题/","link":"","permalink":"http://yoursite.com/2020/07/20/JAVA%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这是一个在写作业时发现的一个有趣的地方. 当时想测试创建多个对象,于是想到使用类数组,于是模仿整形数组的创建方法凭感觉写出了如下代码: 123456789101112class BookTest&#123; public static void test() &#123; Book[] book=new Book[4]; book[0].setTitle(&quot;一本少于200页的测试用书&quot;); book[0].setPageNum(20); Book.detail(book[0]); book[1].setTitle(&quot;测试用书&quot;); book[1].setPageNum(233); Book.detail(book[1]); &#125; 运行结果:Exception in thread “main” java.lang.NullPointerException……. 提示空指针异常. 于是想到类类型数组中的元素为指向对象的指针,和C语言中指针数组相似的概念.使用以上代码创建的只是若干个指针,并没有指向任何对象,因此报错. 然后改成如下代码,使用for循环和new开辟内存空间之后就能对对象属性赋值了. 12345678910111213141516171819202122232425class BookTest&#123; public static void test() &#123; Book[] book=new Book[4]; for(int i=0;i&lt;book.length;i++) &#123; /*********初始化 类 类型数组***************** * * 类数组的一个元素可以理解为指向一个对象的指针 * 未经初始化直接赋值 运行器会报错 * * 因为未经初始化,类数组每个元素指向的是非法地址(野指针)造成编译器报错 * 所以要使用new为每一个元素在堆中开辟合法的内存空间 * *****************************************/ book[i]=new Book(&quot;测试用书&quot;,0); &#125; book[0].setTitle(&quot;一本少于200页的测试用书&quot;); book[0].setPageNum(20); Book.detail(book[0]); book[1].setTitle(&quot;测试用书&quot;); book[1].setPageNum(233); Book.detail(book[1]); &#125;","categories":[],"tags":[]},{"title":"C语言与JAVA数组名作为参数传递的区别","slug":"C语言与JAVA数组名作为参数传递的区别","date":"2020-07-06T16:00:00.000Z","updated":"2022-01-29T23:48:24.143Z","comments":true,"path":"2020/07/07/C语言与JAVA数组名作为参数传递的区别/","link":"","permalink":"http://yoursite.com/2020/07/07/C%E8%AF%AD%E8%A8%80%E4%B8%8EJAVA%E6%95%B0%E7%BB%84%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"首先是C语言12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[5]; int length = sizeof(arr) / sizeof(int); //求数组长度 printf(&quot;数组长度: %d\\n数组长度: %d\\n&quot;, length, length1(arr)); system(&quot;pause&quot;); return 0;&#125;//求数组长度int length1(int arr[]) &#123; return sizeof(arr) / sizeof(int);&#125; 运行结果 从运行结果可以看出,数组名作为参数传入函数时,不能通过sizeof求出数组长度,说明用数组名作参数传入函数时退化成为指向首元素的指针 然后是JAVA12345678910111213public class Array &#123; public static void main(String[] args) &#123; int array[]=new int[6]; System.out.println(&quot;数组长度:&quot;+array.length); System.out.println(&quot;数组长度:&quot;+arrLength(array)); &#125; static int arrLength(int arr[]) &#123; return arr.length; &#125;&#125; 运行结果 java中,数组名作为参数传入方法时,可以正确求出数组长度,在传递时能正确传递数组的地址.","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-05T16:00:00.000Z","updated":"2022-01-18T06:29:33.371Z","comments":true,"path":"2020/06/06/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/06/hello-world/","excerpt":"","text":"测试文档 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment TEST IMG","categories":[],"tags":[{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"},{"name":"test2","slug":"test2","permalink":"http://yoursite.com/tags/test2/"},{"name":"test3","slug":"test3","permalink":"http://yoursite.com/tags/test3/"}]}],"categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"SSH","slug":"SSH","permalink":"http://yoursite.com/tags/SSH/"},{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"},{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"},{"name":"test2","slug":"test2","permalink":"http://yoursite.com/tags/test2/"},{"name":"test3","slug":"test3","permalink":"http://yoursite.com/tags/test3/"}]}