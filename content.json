{"meta":{"title":"Dreamscape","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"线程与进程 并发与并行","slug":"线程与进程 并发与并行","date":"2020-08-08T13:34:20.277Z","updated":"2020-08-10T02:12:32.904Z","comments":true,"path":"2020/08/08/线程与进程 并发与并行/","link":"","permalink":"http://yoursite.com/2020/08/08/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/","excerpt":"","text":"1.线程与进程 进程(Process)是Windows系统中的一个基本概念,它包含着一个运行程序所需要的资源.一个正在运行的程序在操作系统中被视为一个进程,进程可以包括一个或多个线程. 线程(Thread):是进程中的基本执行单元,是操作系统分配CPU时间的基本单位,一个进程可以包含若干个线程,在进程入口执行的第一个线程被视为这个进程的主线程. 2.并发与并行并发是指一个时间段内,有若干程序都在同一个CPU上运行,但任意一个时刻只有一个程序在运行. 并行是指一个时间段内,有若干程序都在几个CPU上运行任意一个时刻点上,有多个程序在同时运行,并且多个程序之间互不干扰. 两者区别如图所示: 并行是多个程序在多个CPU(核心)上同时运行,任意一个时刻可以有很多个程序同时运行,互不干扰. 并发是多个程序在一个CPU上运行,CPU在多个程序之间快速切换,微观上不是同时运行,任意一个时刻只有一个程序在运行,但因为CPU切换速度非常快,所以给人感觉像多个程序同时运行一样,你还没反应过来,CPU已经切换了好几个程序了.","categories":[],"tags":[]},{"title":"Try-catch造成死循环(无限递归)的问题","slug":"Try-catch造成死循环(无限递归)的问题","date":"2020-08-08T13:14:25.368Z","updated":"2020-08-08T13:17:20.256Z","comments":true,"path":"2020/08/08/Try-catch造成死循环(无限递归)的问题/","link":"","permalink":"http://yoursite.com/2020/08/08/Try-catch%E9%80%A0%E6%88%90%E6%AD%BB%E5%BE%AA%E7%8E%AF(%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92)%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"直接上代码:1234567891011121314151617181920import java.util.Scanner;public class TryCatch &#123; public static void main(String[] args) &#123; new Test1().test(); &#125; public static class Test1 &#123; Scanner input=new Scanner(System.in); public int test()&#123; System.out.println(&quot;请输入:&quot;); int temp=1; try&#123; temp=input.nextInt(); &#125;catch(Exception e)&#123; return test(); &#125; System.out.println(temp); return temp; &#125; &#125;&#125; 这段代码原本是想用于接收用户输入并判断输入是否合法,如果输入不合法则调用自己让用户重新输入一次数据.结果输入字符串时造成死循环 然后爆栈… 于是进入调试模式查找问题. 在调试模式中发现 input.nextInt()方法的异常在递归时并未清除而是保留下来,所以catch中的条件一直被触发,造成死循环. 解决方法:在方法中创建Scanner对象. 1234567891011121314public static class Test1 &#123; public int test()&#123; Scanner input=new Scanner(System.in); System.out.println(&quot;请输入:&quot;); int temp=1; try&#123; temp=input.nextInt(); &#125;catch(Exception e)&#123; return test(); &#125; System.out.println(temp); return temp; &#125;&#125;","categories":[],"tags":[]},{"title":"JAVA创建类类型数组遇到的问题","slug":"JAVA创建类类型数组遇到的问题","date":"2020-08-08T13:02:28.335Z","updated":"2020-08-08T13:08:47.811Z","comments":true,"path":"2020/08/08/JAVA创建类类型数组遇到的问题/","link":"","permalink":"http://yoursite.com/2020/08/08/JAVA%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这是一个在写作业时发现的一个有趣的地方. 当时想测试创建多个对象,于是想到使用类数组,于是模仿整形数组的创建方法凭感觉写出了如下代码: 123456789101112class BookTest&#123; public static void test() &#123; Book[] book=new Book[4]; book[0].setTitle(&quot;一本少于200页的测试用书&quot;); book[0].setPageNum(20); Book.detail(book[0]); book[1].setTitle(&quot;测试用书&quot;); book[1].setPageNum(233); Book.detail(book[1]); &#125; 运行结果:Exception in thread “main” java.lang.NullPointerException……. 提示空指针异常. 于是想到类类型数组中的元素为指向对象的指针,和C语言中指针数组相似的概念.使用以上代码创建的只是若干个指针,并没有指向任何对象,因此报错. 然后改成如下代码,使用for循环和new开辟内存空间之后就能对对象属性赋值了. 12345678910111213141516171819202122232425class BookTest&#123; public static void test() &#123; Book[] book=new Book[4]; for(int i=0;i&lt;book.length;i++) &#123; /*********初始化 类 类型数组***************** * * 类数组的一个元素可以理解为指向一个对象的指针 * 未经初始化直接赋值 运行器会报错 * * 因为未经初始化,类数组每个元素指向的是非法地址(野指针)造成编译器报错 * 所以要使用new为每一个元素在堆中开辟合法的内存空间 * *****************************************/ book[i]=new Book(&quot;测试用书&quot;,0); &#125; book[0].setTitle(&quot;一本少于200页的测试用书&quot;); book[0].setPageNum(20); Book.detail(book[0]); book[1].setTitle(&quot;测试用书&quot;); book[1].setPageNum(233); Book.detail(book[1]); &#125;","categories":[],"tags":[]},{"title":"C语言与JAVA数组名作为参数传递的区别","slug":"C语言与JAVA数组名作为参数传递的区别","date":"2020-08-08T10:50:14.911Z","updated":"2020-08-08T11:26:04.460Z","comments":true,"path":"2020/08/08/C语言与JAVA数组名作为参数传递的区别/","link":"","permalink":"http://yoursite.com/2020/08/08/C%E8%AF%AD%E8%A8%80%E4%B8%8EJAVA%E6%95%B0%E7%BB%84%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"首先是C语言12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[5]; int length = sizeof(arr) / sizeof(int); //求数组长度 printf(&quot;数组长度: %d\\n数组长度: %d\\n&quot;, length, length1(arr)); system(&quot;pause&quot;); return 0;&#125;//求数组长度int length1(int arr[]) &#123; return sizeof(arr) / sizeof(int);&#125; 运行结果 从运行结果可以看出,数组名作为参数传入函数时,不能通过sizeof求出数组长度,说明用数组名作参数传入函数时退化成为指向首元素的指针 然后是JAVA12345678910111213public class Array &#123; public static void main(String[] args) &#123; int array[]=new int[6]; System.out.println(&quot;数组长度:&quot;+array.length); System.out.println(&quot;数组长度:&quot;+arrLength(array)); &#125; static int arrLength(int arr[]) &#123; return arr.length; &#125;&#125; 运行结果 java中,数组名作为参数传入方法时,可以正确求出数组长度,在传递时能正确传递数组的地址.","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-12-31T16:00:00.000Z","updated":"2020-08-10T02:10:22.398Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"http://yoursite.com/2020/01/01/hello-world/","excerpt":"","text":"测试文档 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment TEST IMG","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}],"categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}