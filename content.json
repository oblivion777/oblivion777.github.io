{"meta":{"title":"Dreamscape","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"通过dig命令理解DNS迭代解析","slug":"通过dig命令理解DNS迭代解析","date":"2020-08-22T16:36:39.000Z","updated":"2020-08-22T18:42:33.719Z","comments":true,"path":"2020/08/23/通过dig命令理解DNS迭代解析/","link":"","permalink":"http://yoursite.com/2020/08/23/%E9%80%9A%E8%BF%87dig%E5%91%BD%E4%BB%A4%E7%90%86%E8%A7%A3DNS%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%9E%90/","excerpt":"","text":"最近给Github Pages弄域名和CDN加速,为了查看DNS的解析过程,稍微学习了DNS迭代解析. 迭代解析是以DNS客户端为中心进行查询,如图所示: DNS迭代解析流程下面以Linux系统下的dig +trace blog.dreamscape.ink为例: 获取本地DNS记录的全球根域名服务器地址 最先回复的根域名服务器将ink顶级域名服务器列表返回给客户端 根域名服务器199.9.14.201:53(b.root-servers.net)返回ink顶级域名服务器列表. .ink顶级域名服务器返回二级域名dreamscape.ink的NS服务器列表 .ink顶级域名服务器212.18.248.41:53(c.nic.ink)查询得到dreamscape.ink是由cloudflare管理的,返回cloudflare的NS地址. cloudflareDNS服务器返回最终的结果. cloudflareDNS服务器108.162.195.191:53(tate.ns.cloudflare.com)将查询到blog.dreamscape.ink的A记录信息返回给客户端. blog.dreamscape.ink是经过cloudflare的CDN加速域名,返回了3条A记录,这三条A记录就是最终查询结果.","categories":[],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"}]},{"title":"解析JSON","slug":"json解析","date":"2020-08-09T16:00:00.000Z","updated":"2020-08-13T05:16:30.419Z","comments":true,"path":"2020/08/10/json解析/","link":"","permalink":"http://yoursite.com/2020/08/10/json%E8%A7%A3%E6%9E%90/","excerpt":"","text":"JSON:JavaScript Object Notation ,JS对象简谱 , 是一种轻量级的数据交换格式. 本文讲解使用GSON解析JSON Gson的使用前提:导入gson的jar包 思路:把JSON字符串转成Java对象 主要的方法： Gson fromJson(String jsonString,Object) 用于把json字符串转换成java对象 String toJson(Object obj) 把obj对象变成json字符串 解析json字符串首先创建一个用于解析的字符串.这里用对象创建,创建后把结果写入文件.123456789101112131415161718192021222324252627282930313233public class TestJSON &#123; @Test public void testJSON() throws IOException &#123; Per p=new Per(&quot;Alice&quot;,23); //创建json对象 Gson gson = new Gson(); //获取对象p的json字符串 String json = gson.toJson(p); System.out.println(json); //写入文件 File file=new File(&quot;E:\\\\CSOURCE\\\\Kaikeba\\\\lib\\\\test\\\\test\\\\test1.json&quot;); PrintStream ps=new PrintStream(file); ps.println(json); ps.close(); &#125; //用于创建Json字符串的类 class Per&#123; String name=&quot;NULL&quot;; int age=-1; public Per(String name, int age) &#123; this.name = name; this.age = age; &#125; public Per() &#123; &#125; @Override public String toString() &#123; return &quot;Per&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; &#125; 输出的内容: 从json文件获取json字符串后进行解析1234567891011121314@Testpublic void testJSON() throws IOException &#123; File file=new File(&quot;E:\\\\CSOURCE\\\\Kaikeba\\\\lib\\\\test\\\\test\\\\test1.json&quot;); //由json文件创建对象 Per p2=new Per(); //打印默认值 System.out.println(&quot;默认值:&quot;+p2); //获取带缓存的字符输入流 BufferedReader br=new BufferedReader(new InputStreamReader(new FileInputStream(file))); //解析json字符串并将数据写入对象p2 String s=br.readLine(); p2=gson.fromJson(s,Per.class); System.out.println(&quot;由json文件读入的对象数值:&quot;+p2);&#125; 解析数组123456789101112@Testpublic void analysisJSON()&#123; //创建JSON对象 Gson gson=new Gson(); //转换 &#123;&quot;id&quot;:[100,104,105,233,256]&#125; HashMap data=gson.fromJson(&quot;&#123;\\&quot;id\\&quot;:[100,104,105,233,256]&#125;&quot;,HashMap.class); List id= (List) data.get(&quot;id&quot;); //遍历列表 for(Object o:id)&#123; System.out.println(o); &#125;&#125;","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"线程与进程 并发与并行","slug":"线程与进程 并发与并行","date":"2020-08-08T13:34:20.277Z","updated":"2020-08-10T02:12:32.904Z","comments":true,"path":"2020/08/08/线程与进程 并发与并行/","link":"","permalink":"http://yoursite.com/2020/08/08/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%20%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C/","excerpt":"","text":"1.线程与进程 进程(Process)是Windows系统中的一个基本概念,它包含着一个运行程序所需要的资源.一个正在运行的程序在操作系统中被视为一个进程,进程可以包括一个或多个线程. 线程(Thread):是进程中的基本执行单元,是操作系统分配CPU时间的基本单位,一个进程可以包含若干个线程,在进程入口执行的第一个线程被视为这个进程的主线程. 2.并发与并行并发是指一个时间段内,有若干程序都在同一个CPU上运行,但任意一个时刻只有一个程序在运行. 并行是指一个时间段内,有若干程序都在几个CPU上运行任意一个时刻点上,有多个程序在同时运行,并且多个程序之间互不干扰. 两者区别如图所示: 并行是多个程序在多个CPU(核心)上同时运行,任意一个时刻可以有很多个程序同时运行,互不干扰. 并发是多个程序在一个CPU上运行,CPU在多个程序之间快速切换,微观上不是同时运行,任意一个时刻只有一个程序在运行,但因为CPU切换速度非常快,所以给人感觉像多个程序同时运行一样,你还没反应过来,CPU已经切换了好几个程序了.","categories":[],"tags":[]},{"title":"Try-catch造成死循环(无限递归)的问题","slug":"Try-catch造成死循环(无限递归)的问题","date":"2020-08-08T13:14:25.368Z","updated":"2020-08-10T02:19:15.528Z","comments":true,"path":"2020/08/08/Try-catch造成死循环(无限递归)的问题/","link":"","permalink":"http://yoursite.com/2020/08/08/Try-catch%E9%80%A0%E6%88%90%E6%AD%BB%E5%BE%AA%E7%8E%AF(%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92)%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"直接上代码:1234567891011121314151617181920import java.util.Scanner;public class TryCatch &#123; public static void main(String[] args) &#123; new Test1().test(); &#125; public static class Test1 &#123; Scanner input=new Scanner(System.in); public int test()&#123; System.out.println(&quot;请输入:&quot;); int temp=1; try&#123; temp=input.nextInt(); &#125;catch(Exception e)&#123; return test(); &#125; System.out.println(temp); return temp; &#125; &#125;&#125; 这段代码原本是想用于接收用户输入并判断输入是否合法,如果输入不合法则调用自己让用户重新输入一次数据.结果输入字符串时造成死循环 然后爆栈… 于是进入调试模式查找问题. 在调试模式中发现 input.nextInt()方法的异常在递归时并未清除而是保留下来,所以catch中的条件一直被触发,造成死循环. 解决方法:在方法中创建Scanner对象. 1234567891011121314public static class Test1 &#123; public int test()&#123; Scanner input=new Scanner(System.in); System.out.println(&quot;请输入:&quot;); int temp=1; try&#123; temp=input.nextInt(); &#125;catch(Exception e)&#123; return test(); &#125; System.out.println(temp); return temp; &#125;&#125;","categories":[],"tags":[]},{"title":"JAVA创建类类型数组遇到的问题","slug":"JAVA创建类类型数组遇到的问题","date":"2020-08-08T13:02:28.335Z","updated":"2020-08-08T13:08:47.811Z","comments":true,"path":"2020/08/08/JAVA创建类类型数组遇到的问题/","link":"","permalink":"http://yoursite.com/2020/08/08/JAVA%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"这是一个在写作业时发现的一个有趣的地方. 当时想测试创建多个对象,于是想到使用类数组,于是模仿整形数组的创建方法凭感觉写出了如下代码: 123456789101112class BookTest&#123; public static void test() &#123; Book[] book=new Book[4]; book[0].setTitle(&quot;一本少于200页的测试用书&quot;); book[0].setPageNum(20); Book.detail(book[0]); book[1].setTitle(&quot;测试用书&quot;); book[1].setPageNum(233); Book.detail(book[1]); &#125; 运行结果:Exception in thread “main” java.lang.NullPointerException……. 提示空指针异常. 于是想到类类型数组中的元素为指向对象的指针,和C语言中指针数组相似的概念.使用以上代码创建的只是若干个指针,并没有指向任何对象,因此报错. 然后改成如下代码,使用for循环和new开辟内存空间之后就能对对象属性赋值了. 12345678910111213141516171819202122232425class BookTest&#123; public static void test() &#123; Book[] book=new Book[4]; for(int i=0;i&lt;book.length;i++) &#123; /*********初始化 类 类型数组***************** * * 类数组的一个元素可以理解为指向一个对象的指针 * 未经初始化直接赋值 运行器会报错 * * 因为未经初始化,类数组每个元素指向的是非法地址(野指针)造成编译器报错 * 所以要使用new为每一个元素在堆中开辟合法的内存空间 * *****************************************/ book[i]=new Book(&quot;测试用书&quot;,0); &#125; book[0].setTitle(&quot;一本少于200页的测试用书&quot;); book[0].setPageNum(20); Book.detail(book[0]); book[1].setTitle(&quot;测试用书&quot;); book[1].setPageNum(233); Book.detail(book[1]); &#125;","categories":[],"tags":[]},{"title":"C语言与JAVA数组名作为参数传递的区别","slug":"C语言与JAVA数组名作为参数传递的区别","date":"2020-07-06T16:00:00.000Z","updated":"2020-08-10T05:58:48.266Z","comments":true,"path":"2020/07/07/C语言与JAVA数组名作为参数传递的区别/","link":"","permalink":"http://yoursite.com/2020/07/07/C%E8%AF%AD%E8%A8%80%E4%B8%8EJAVA%E6%95%B0%E7%BB%84%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"首先是C语言12345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[5]; int length = sizeof(arr) / sizeof(int); //求数组长度 printf(&quot;数组长度: %d\\n数组长度: %d\\n&quot;, length, length1(arr)); system(&quot;pause&quot;); return 0;&#125;//求数组长度int length1(int arr[]) &#123; return sizeof(arr) / sizeof(int);&#125; 运行结果 从运行结果可以看出,数组名作为参数传入函数时,不能通过sizeof求出数组长度,说明用数组名作参数传入函数时退化成为指向首元素的指针 然后是JAVA12345678910111213public class Array &#123; public static void main(String[] args) &#123; int array[]=new int[6]; System.out.println(&quot;数组长度:&quot;+array.length); System.out.println(&quot;数组长度:&quot;+arrLength(array)); &#125; static int arrLength(int arr[]) &#123; return arr.length; &#125;&#125; 运行结果 java中,数组名作为参数传入方法时,可以正确求出数组长度,在传递时能正确传递数组的地址.","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-06-05T16:00:00.000Z","updated":"2020-08-11T04:44:17.583Z","comments":true,"path":"2020/06/06/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/06/hello-world/","excerpt":"","text":"测试文档 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment TEST IMG","categories":[],"tags":[{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"},{"name":"test2","slug":"test2","permalink":"http://yoursite.com/tags/test2/"},{"name":"test3","slug":"test3","permalink":"http://yoursite.com/tags/test3/"}]}],"categories":[],"tags":[{"name":"DNS","slug":"DNS","permalink":"http://yoursite.com/tags/DNS/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"},{"name":"C语言","slug":"C语言","permalink":"http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"},{"name":"test2","slug":"test2","permalink":"http://yoursite.com/tags/test2/"},{"name":"test3","slug":"test3","permalink":"http://yoursite.com/tags/test3/"}]}